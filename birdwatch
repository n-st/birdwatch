#!/usr/bin/env python3

from datetime import datetime, timedelta
import os
import socket
import time
import sys
import re
import threading
import signal

from email.mime.text import MIMEText
from subprocess import Popen, PIPE

SOCKETS = {
    'IPv4': '/var/run/bird/bird.ctl',
    'IPv6': '/var/run/bird/bird6.ctl',
}
NOTIFICATION_DELAY = timedelta(seconds=120)
INTERESTING_PROTOCOLS = ['BGP']
CHECK_INTERVAL = 20
HOSTNAME = socket.gethostname()
MAIL_FROM = 'birdwatch@' + socket.getfqdn()
MAIL_TO = 'root'


class Protocol:
    def __init__(self, proto_name, proto_type, proto_table, proto_state, proto_since, proto_info):
        self.name = proto_name
        self.type = proto_type
        self.table = proto_table
        self.state = proto_state
        self.since = proto_since
        self.info = proto_info

    def __str__(self):
        return 'Protocol<%s:%s>:%s' % (self.type, self.name, self.state)


class ProtocolHandler:
    def __init__(self, socket_alias):
        self.socket_alias = socket_alias
        self.last_state = {}  # protocol state after last update
        self.last_alert_state = {}  # protocol state that was sent in the last alert
        self.alert_time = {}  # time when an alert should be sent for this protocol
        self.protocol_log = {}  # storage for actual Protocol object (to obtain detailed info later)
        self.touched = []  # protocols that were present in last update

    def update(self, protocols):
        self.touched = []
        self.inject_protocols(protocols)
        self.find_vanished()
        self.alert_for_changes()

    def inject_protocol(self, protocol):
        if type(protocol) is not Protocol:
            raise TypeError

        if protocol.type not in INTERESTING_PROTOCOLS:
            return

        self.touched.append(protocol.name)

        self.protocol_log[protocol.name] = protocol

        if protocol.name not in self.last_state:
            self.last_state[protocol.name] = 'absent'
            self.last_alert_state[protocol.name] = 'absent'

        if protocol.state != self.last_state[protocol.name]:
            # changed
            print(
                '%s: Protocol %s has changed from %s to %s' % (
                    self.socket_alias,
                    protocol.name,
                    self.last_state[protocol.name],
                    protocol.state
                )
            )
            self.last_state[protocol.name] = protocol.state
            self.alert_time[protocol.name] = datetime.now() + NOTIFICATION_DELAY

    def inject_protocols(self, protocols):
        if type(protocols) is not list:
            raise TypeError

        for protocol in protocols:
            self.inject_protocol(protocol)

    def purge_protocol(self, protocol_name):
        del self.last_state[protocol_name]
        del self.last_alert_state[protocol_name]
        del self.protocol_log[protocol_name]

    def find_vanished(self):
        for protocol in self.last_state:
            if self.last_state[protocol] != 'vanished' and protocol not in self.touched:
                # Protocol has vanished. Schedule an alert (that will also remove the protocol from our watch).
                print(
                    '%s: Protocol %s has changed from %s to %s' % (
                        self.socket_alias,
                        protocol,
                        self.last_state[protocol],
                        'vanished'
                    )
                )
                self.last_state[protocol] = 'vanished'
                self.alert_time[protocol] = datetime.now() + NOTIFICATION_DELAY

    def alert_for_changes(self):
        now_x = {}
        body = []

        for protocol in self.alert_time:
            if self.alert_time[protocol] and self.alert_time[protocol] <= datetime.now():
                self.alert_time[protocol] = None

                state = self.last_state[protocol]
                if state == self.last_alert_state[protocol]:
                    print(
                        '%s: Would issue alert for protocol %s, but it has returned to previous state (%s). Clearing alert flag.' % (self.socket_alias, protocol, state)
                    )
                    continue

                self.last_alert_state[protocol] = state

                proto = self.protocol_log[protocol]

                if state == 'vanished':
                    body += ['%-15s%-15s%-15s%-15s%-15s'
                             % (proto.name, proto.type, 'vanished', '', '')]
                    self.purge_protocol(protocol)

                else:
                    body += ['%-15s%-15s%-15s%-15s%-15s'
                             % (proto.name, proto.type, proto.state, proto.since, proto.info)]

                if state not in now_x:
                    now_x[state] = 1
                else:
                    now_x[state] += 1

        if now_x:
            body = ['%-15s%-15s%-15s%-15s%-15s'
                    % ('NAME', 'PROTOCOL', 'STATE', 'SINCE', 'INFO')] \
                   + body
            subject = 'Birdwatch %s %s: %s' % (
                HOSTNAME,
                self.socket_alias,
                ', '.join(['%d %s' % (now_x[x], x) for x in now_x])
            )
            send_mail(subject, '\n'.join(body))


def recvline(sock):
    response = b''
    b = b''
    while b != b'\n':
        b = sock.recv(1)
        response += b
    return response.decode('utf-8')


def send_mail(subject, body):
    msg = MIMEText(body)
    msg["From"] = MAIL_FROM
    msg["To"] = MAIL_TO
    msg["Subject"] = subject
    print('Sending mail with subject "%s"' % subject)
    p = Popen(["sendmail", "-t", "-oi"], stdin=PIPE)
    p.communicate(msg.as_string().encode('utf-8'))


def watch_socket(socket_path, socket_alias, sigterm_handler):
    try:
        handler = ProtocolHandler(socket_alias)

        client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        client.connect(socket_path)

        preamble = recvline(client)
        if not (preamble.startswith('0001 BIRD ') and preamble.endswith('ready.\n')):
            raise Exception("Bird didn't send correct preamble on socket.")

        while True:
            client.send(b'show protocols\n')

            response = []
            line = ''
            while not line.startswith('0000'):
                line = recvline(client)
                line = re.sub(r'^(\d{4})-', r'\1 ', line)
                response += [line]

            protocols = []

            code = ''
            for line in response:
                parts = re.split('\s+', line)
                if parts[0]:
                    code = parts[0]
                if code == '1002':
                    proto_name, proto_type, proto_table, proto_state, proto_since, proto_info = parts[1:7]
                    proto = Protocol(proto_name, proto_type, proto_table, proto_state, proto_since, proto_info)
                    protocols.append(proto)

            handler.update(protocols)

            for i in range(CHECK_INTERVAL):
                if sigterm_handler.kill_now:
                    return
                time.sleep(1)

    except Exception as e:
        import traceback
        subject = 'Birdwatch %s %s: %s' % (HOSTNAME, socket_alias, 'error')
        send_mail(subject, 'Lost connection to bird:\n%s' % traceback.format_exc())


class GracefulKiller:
    kill_now = False

    def __init__(self):
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)

    def exit_gracefully(self, signum, frame):
        print('Program now set to terminate after next cycle')
        self.kill_now = True


def main():
    killer = GracefulKiller()

    for sock in SOCKETS.items():
        print(sock)
        t = threading.Thread(target=watch_socket, args=(sock[1], sock[0], killer))
        t.daemon = False
        t.start()


if __name__ == "__main__":
    main()
