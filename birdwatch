#!/usr/bin/env python3

from datetime import datetime, timedelta
import os
import socket
import time
import sys
import re
import threading
import signal

from email.mime.text import MIMEText
from subprocess import Popen, PIPE

SOCKETS = {
    'IPv4': '/var/run/bird/bird.ctl',
    'IPv6': '/var/run/bird/bird6.ctl',
}
NOTIFICATION_DELAY = timedelta(seconds=120)
INTERESTING_PROTOCOLS = ['BGP']
CHECK_INTERVAL = 20
HOSTNAME = socket.gethostname()
MAIL_FROM = 'birdwatch@' + socket.getfqdn()
MAIL_TO = 'root'


class Protocol:
    def __init__(self, proto_name, proto_type, proto_table, proto_state, proto_since, proto_info):
        self.name = proto_name
        self.type = proto_type
        self.table = proto_table
        self.state = proto_state
        self.since = proto_since
        self.info = proto_info

    def __str__(self):
        return 'Protocol<%s:%s>:%s' % (self.type, self.name, self.state)


class ProtocolHandler:
    last_state = {}
    last_alert_state = {}
    alert_time = {}
    protocol_log = {}
    touched = []

    def __init__(self, socket_alias):
        self.socket_alias = socket_alias

    def new_session(self):
        self.touched = []

    def inject_protocol(self, protocol):
        if type(protocol) is not Protocol:
            raise TypeError

        if protocol.type not in INTERESTING_PROTOCOLS:
            return

        self.touched.append(protocol.name)

        self.protocol_log[protocol.name] = protocol

        if protocol.name not in self.last_state:
            self.last_state[protocol.name] = 'absent'
            self.last_alert_state[protocol.name] = 'absent'

        if protocol.state != self.last_state[protocol.name]:
            # changed
            print(
                'Protocol %s has changed from %s to %s' % (
                    protocol.name,
                    self.last_state[protocol.name],
                    protocol.state
                )
            )
            self.last_state[protocol.name] = protocol.state
            self.alert_time[protocol.name] = datetime.now() + NOTIFICATION_DELAY

    def inject_protocols(self, protocols):
        if type(protocols) is not list:
            raise TypeError

        for protocol in protocols:
            self.inject_protocol(protocol)

    def get_changes(self):
        now_x = {}
        body = []

        for protocol in self.last_state:
            if protocol not in self.touched:
                # Protocol has vanished. Schedule an alert.
                self.last_state[protocol] = 'vanished'
                del self.protocol_log[protocol]
                self.alert_time[protocol] = datetime.now() + NOTIFICATION_DELAY

        for protocol in self.alert_time:
            if self.alert_time[protocol] and self.alert_time[protocol] <= datetime.now():
                self.alert_time[protocol] = None

                state = self.last_state[protocol]
                if state == self.last_alert_state[protocol]:
                    print(
                        'Would issue alert for protocol %s, but it has returned to previous state (%s).' +
                        'Clearing alert flag.' % (protocol, state)
                    )
                    continue

                self.last_alert_state[protocol] = state

                if state == 'vanished':
                    body += ['Protocol %s has vanished.' % protocol]
                else:
                    proto = self.protocol_log[protocol]
                    body += ['%-15s%-15s%-15s%-15s%-15s'
                             % (proto.name, proto.type, proto.state, proto.since, proto.info)]

                if state not in now_x:
                    now_x[state] = 1
                else:
                    now_x[state] += 1

        if now_x:
            body = ['%-15s%-15s%-15s%-15s%-15s'
                    % ('NAME', 'PROTOCOL', 'STATE', 'SINCE', 'INFO')] \
                   + body
            subject = 'Birdwatch %s %s: %s' % (
                HOSTNAME,
                self.socket_alias,
                ', '.join(['%d %s' % (now_x[x], x) for x in now_x])
            )
            send_mail(subject, '\n'.join(body))


def recvline(sock):
    response = b''
    b = b''
    while b != b'\n':
        b = sock.recv(1)
        response += b
    return response.decode('utf-8')


def send_mail(subject, body):
    msg = MIMEText(body)
    msg["From"] = MAIL_FROM
    msg["To"] = MAIL_TO
    msg["Subject"] = subject
    print('Sending mail with subject "%s"' % subject)
    p = Popen(["sendmail", "-t", "-oi"], stdin=PIPE)
    p.communicate(msg.as_string().encode('utf-8'))


def watch_socket(socket_path, socket_alias, sigterm_handler):
    try:
        handler = ProtocolHandler(socket_alias)

        client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        client.connect(socket_path)

        preamble = recvline(client)
        if not (preamble.startswith('0001 BIRD ') and preamble.endswith('ready.\n')):
            raise Exception("Bird didn't send correct preamble on socket.")

        while True:
            client.send(b'show protocols\n')

            response = []
            line = ''
            while not line.startswith('0000'):
                line = recvline(client)
                line = re.sub(r'^(\d{4})-', r'\1 ', line)
                response += [line]

            protocols = []

            code = ''
            for line in response:
                parts = re.split('\s+', line)
                if parts[0]:
                    code = parts[0]
                if code == '1002':
                    proto_name, proto_type, proto_table, proto_state, proto_since, proto_info = parts[1:7]
                    proto = Protocol(proto_name, proto_type, proto_table, proto_state, proto_since, proto_info)
                    protocols.append(proto)

            handler.new_session()
            handler.inject_protocols(protocols)
            handler.get_changes()

            for i in range(CHECK_INTERVAL):
                if sigterm_handler.kill_now:
                    return
                time.sleep(1)

    except Exception as e:
        subject = 'Birdwatch %s %s: %s' % (HOSTNAME, socket_alias, 'connection error')
        send_mail(subject, 'Lost connection to bird: %s' % str(e))
        sys.exit(1)


class GracefulKiller:
    kill_now = False

    def __init__(self):
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)

    def exit_gracefully(self, signum, frame):
        print('Program now set to terminate after next cycle')
        self.kill_now = True


def main():
    killer = GracefulKiller()

    for sock in SOCKETS.items():
        print(sock)
        t = threading.Thread(target=watch_socket, args=(sock[1], sock[0], killer))
        t.daemon = False
        t.start()


if __name__ == "__main__":
    main()
